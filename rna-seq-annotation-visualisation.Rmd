---
title: "RNA-seq Analysis in R"
subtitle: "Annotation and Visualisation of RNA-seq results"
author: "Stephane Ballereau, Mark Dunning, Oscar Rueda, Ashley Sawle"
date: '`r format(Sys.time(), "Last modified: %d %b %Y")`'
output:
  html_notebook:
    toc: yes
    toc_float: yes
  html_document:
    toc: yes
    toc_float: yes
minutes: 300
layout: page
bibliography: ref.bib
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

**Original Authors: Belinda Phipson, Anna Trigos, Matt Ritchie, Maria Doyle, Harriet Dashnow, Charity Law**
Based on the course [RNAseq analysis in R](http://combine-australia.github.io/2016-05-11-RNAseq/) delivered on May 11/12th 2016

Before starting this section, we will make sure we have all the relevant objects from the Differential Expression analysis present.

```{r}
suppressPackageStartupMessages(library(edgeR))
load("Robjects/DE.Rdata")
```


## Adding annotation and saving the results

We have a list of significantly differentially expressed genes, but the only annotation we can see is the Entrez Gene ID, which is not very informative. 

```{r}
topTable(fit.cont)
```

We would like to add some annotation information. There are a number of ways to do this, but we will demonstrate how to do this using the *org.Mm.eg.db* package. This package is one of several *organism-level* packages which are re-built every 6 months. These packages are listed on the [annotation section](http://bioconductor.org/packages/release/BiocViews.html#___AnnotationData) of the Bioconductor, and are installed in the same way as regular Bioconductor packages. An alternative approachj is to use `biomaRt`, and interface to the [BioMart](http://www.biomart.org/) resource. BioMart is much more comprehensive, but the organism package fit better into the Bioconductor workflow.


```{r eval=FALSE}
source("http://www.bioconductor.org/biocLite.R")
biocLite("org.Mm.eg.db")
# For Human
biocLite("org.Hs.eg.db")
```

The packages are larger in size that Bioconductor software pacakges, but essentially they are databases that can be used to make *offline* queries. 

```{r}
library(org.Mm.eg.db)
```


First we need to decide what information we want. In order to see what we can extract we can run the `columns` function on the annotation database.

```{r}
columns(org.Mm.eg.db)
```

We are going to filter the database by a key or set of keys in order to extract the information we want. Valid names for the key can be retrieved with the `keytypes` function.

```{r}
keytypes(org.Mm.eg.db)
```

We should see `ENTREZID`, which is the type of key we are going to use in this case. If we are unsure what values are acceptable for the key, we can check what keys are valid with `keys`

```{r}
keys(org.Mm.eg.db, keytype="ENTREZID")[1:10]
```



```{r}
## Build up the query step-by-step
my.keys <- c("12992", "13358","20531")
my.keys %in% keys(org.Mm.eg.db, keytype="ENTREZID")

```

Let's build up the query step by step.

```{r eval=FALSE}
select(org.Mm.eg.db,


```



To annotate our results, we definitely want gene symbols and perhaps the full gene name. Let's build up our annotation information in a separate data frame using the `select` function.

```{r}
ann <- select(org.Mm.eg.db,keys=rownames(fit.cont),columns=c("ENTREZID","SYMBOL","GENENAME"))
# Have a look at the annotation
ann
```

Let's double check that the `ENTREZID` column matches exactly to our `fit.cont` rownames.

```{r}
table(ann$ENTREZID==rownames(fit.cont))
```

We can slot in the annotation information into the `genes` slot of `fit.cont`. (Please note that if the `select` function returns a 1:many mapping then you can't just append the annotation to the fit object.)

```{r}
fit.cont$genes <- ann
```

Now when we run the `topTable` command, the annotation information should be included in the output.

```{r}
topTable(fit.cont,coef="B.PregVsLac",sort.by="p")
```

To get the full table (i.e. the information for all genes, not just the top 10) we can specify `n="Inf"`.

```{r}
limma.res <- topTable(fit.cont,coef="B.PregVsLac",sort.by="p",n="Inf")
```

We can save the results table using the `write.csv` function, which writes the results out to a csv file that you can open in excel.

```{r}
write.csv(limma.res,file="B.PregVsLacResults.csv",row.names=FALSE)
```

**A note about deciding how many genes are significant**: In order to decide which genes are differentially expressed, we usually take a cut-off of 0.05 on the adjusted p-value, NOT the raw p-value. This is because we are testing more than 15000 genes, and the chances of finding differentially expressed genes is very high when you do that many tests. Hence we need to control the false discovery rate, which is the adjusted p-value column in the results table. What this means is that if 100 genes are significant at a 5\% false discovery rate, we are willing to accept that 5 will be false positives. Note that the `decideTests` function displays significant genes at 5\% FDR.




## Genomic Locations

- workflow to add genomic locations to the annotation table
- export tracks
- plot locations

It might seem natural to add genomic locations to our annotation table, and possibly a bit odd that the `org.Mm.eg.db` package does not supply such mappings. In fact, there is a whole suite of package for performing this, and more-advanced queries. These are listed on the Bioconductor [annotation page](http://bioconductor.org/packages/release/BiocViews.html#___AnnotationData) and have the prefix `TxDb.`

The package we will be using is `TxDb.Mmusculus.UCSC.mm10.knownGene`. Packages are available for other organisms and genome builds. It is even possible to *build your own database* if one does not exist. See `vignette("GenomicFeatures")` for details

```{r eval=FALSE}
source("http://www.bioconductor.org/biocLite.R")
biocLite("TxDb.Mmusculus.UCSC.mm10.knownGene")

## For Humans
biocLite("TxDb.Hsapiens.UCSC.hg19.knownGene")

```

We load the library in the usual fashion and create a new object to save some typing. As with the `org.` packages, we can query what columns are available with `columns`,

```{r}
library(TxDb.Mmusculus.UCSC.mm10.knownGene)
tx <- TxDb.Mmusculus.UCSC.mm10.knownGene
columns(tx)
```

The `select` function is used in the same manner.

```{r}
keys <- c("12992", "13358","20531")
select(tx, keys=keys,
       keytype = "GENEID",
       columns=c("EXONID","EXONSTART","EXONEND"))

```


```{r}
exo <- exonsBy(tx,"gene")
```


## Exporting tracks

It is also possible to save the results of a Bioconductor analysis in a browser to enable interactive analysis
and integration with other data types, or sharing with collaborators. For instance, we might want a
browser track to indicate where our differentially-expressed genes are located. We shall use the bed
format to display these locations.

At the moment, we have a GenomicFeatures object that represents every exon. However, we do not
need this level of granularity for the bed output

Select the names of the statistically significant genes from the edgeR output in the usual
manner.

```{r}
tt <- topTable(fit.cont,coef="B.PregVsLac",n=Inf)
sigGenes <- tt[tt$adj.P.Val < 0.05,]
sigGenes
```
Use the range function to obtain a single range for every gene. Get the genomic intervals that correspond to these DE genes.

```{r}
exoRanges <- unlist(range(exo))
sigRegions <- exoRanges[na.omit(match(sigGenes$ENTREZID, names(exoRanges)))]
sigRegions
```

Rather than just representing the genomic locations, the .bed format is also able to colour each range
according to some property of the analysis (e.g. direction and magnitude of change) to help highlight
particular regions of interest. A score can also be displayed when a particular region is clicked-on.
A useful propery of GenomicRanges is that we can attach metadata to each range using the mcols
function. The metadata can be supplied in the form of a data frame.

```{r}
mcols(sigRegions) <- sigGenes[match(names(sigRegions), sigGenes[,1]),]
sigRegions
```

```{r}
seqlevels(sigRegions)
sigRegions <- keepSeqlevels(sigRegions, paste0("chr", c(1:19,"X","Y")))
```

Create a score from the p-values that will displayed under each region, and colour scheme
for the regions based on the fold-change. For convenience, restrict the fold changes to be within the
region -3 to 3.

```{r}
sigRegions
Score <- -log10(sigRegions$adj.P.Val)
rbPal <-colorRampPalette(c("red", "blue"))
logfc <- pmax(sigRegions$logFC, -3)
logfc <- pmin(logfc , 3)
Col <- rbPal(10)[as.numeric(cut(logfc, breaks = 10))]
```

The colours and score can be saved in the GRanges object and score and itemRgb columns respectively
and will be used to construct the track when exporting. The rtracklayer function can be used to import
and export browsers tracks.

 Export the signifcant results from the DE analysis as a .bed track using rtracklayer. You
can load the resulting file in IGV, if you wish.
```{r}
mcols(sigRegions)$score <- Score
mcols(sigRegions)$itemRgb <- Col
library(rtracklayer)
export(sigRegions , con = "topHits.bed")
```

## Extracting Reads


```{r}
library(GenomicAlignments)
```

```{r}
generegion <- exo[["12992"]]
getwd()
bam <- readGAlignments(file="bam/MCL1.DG.bam",
                       param=ScanBamParam(which=generegion))
bam
```



## An aside - Acessing Genome Sequence

## Brief Introduction to ggplot2


```{r}
library(ggplot2)

top200 <- tt[1:200,]

ggplot(tt, aes(x = logFC, y=B)) + geom_point(alpha=0.4) + scale_color_manual(values=c("black","red")) + geom_text(data=top200, aes(x=logFC,y=B,label=SYMBOL),col="blue",alpha=0.4)

```


> ## Challenge {.challenge}
>
> Use ggplot2 to re-construct the MA- plot from above.
>

**Solution**

```{r,echo=FALSE}
# Soution
tt <- topTable(fit.cont,coef="B.PregVsLac",n=Inf)
ggplot(tt, aes(x = AveExpr, y=logFC,col=adj.P.Val < 0.05)) + geom_point() + scale_color_manual(values=c("black","red")) 

```


## Composing plots with ggbio

We will now take a brief look at one of the visualisation packages in Bioconductor that takes advantage
of the GenomicRanges and GenomicFeatures object-types. In this section we will show a worked
example of how to combine several types of genomic data on the same plot. The documentation for
ggbio is very extensive and contains lots of examples.

http://www.tengfei.name/ggbio/docs/

The Gviz package is another Bioconductor package that specialising in genomic visualisations, but we
will not explore this package in the course.

The Manhattan plot is a common way of visualising genome-wide results, and this is implemented as the
`plotGrandLinear` function. We have to supply a value to display on the y-axis, typically this is some
measure of significance. Changing this variable displayed on the y-axis is done by using the aes function,
which is inherited from ggplot2. The positioning of points on the x-axis is handled automatically by
ggbio, using the ranges information to get the genomic coordinates of the ranges of interest.

```{r}
library(ggbio)
plotGrandLinear(sigRegions , aes(y = score))
mcols(sigRegions)$Up <- logfc > 0
plotGrandLinear(sigRegions, aes(y = logFC, col = Up))
```

A useful function within ggbio is autoplot, which will construct an appropriate plot based on the
object-type of the input. For example, ggbio is able to plot the structure of genes according to a
particular model represented by a GenomicFeatures object.


```{r}
autoplot(tx, which=exo[["24117"]])
```

We can even plot the location of sequencing reads if they have been imported using readGAlignments
function (or similar).

```{r}
myreg <- flank(reduce(exo[["24117"]]), 1000, both = T)
bam <- readGAlignments(file="bam/MCL1.DG.bam",
                       param=ScanBamParam(which=myreg),use.names = TRUE)

autoplot(bam,which=myreg)
```

```{r}
autoplot(bam , stat = "coverage")
```
Like ggplot2, ggbio plots can be saved as objects that can later be modified, or combined together to
form more complicated plots. If saved in this way, the plot will only be displayed on a plotting device
when we query the object. This strategy is useful when we want to add a common element (such as
an ideogram) to a plot composition and don’t want to repeat the code to generate the plot every time.

```{r}
#idPlot <- plotIdeogram(genome = "mm10")
#idPlot
geneMod <- autoplot(tx, which = myreg)
reads1 <- autoplot(bam, stat = "coverage")
tracks(geneMod ,reads1)
```


